% titlepage-demo.tex
\documentclass{beamer}

% items enclosed in square brackets are optional; explanation below
\title{Verifying filesystems in ACL2}
\subtitle{Towards verifying file recovery tools}
\author{Mihir Mehta}
\institute{
  Department of Computer Science\\
  University of Texas at Austin\\[1ex]
  \texttt{mihir@cs.utexas.edu}
}
\date{09 March, 2017}

\begin{document}

%--- the titlepage frame -------------------------%
\begin{frame}[plain]
  \titlepage
\end{frame}

%--- the presentation begins here ----------------%
\begin{frame}{Overview}
  \begin{enumerate}
  \item Why we need a verified filesystem
  \item Our approach
  \item Progress so far
  \item Future work
  \end{enumerate}
\end{frame}

\begin{frame}{Why we need a verified filesystem}
  \begin{itemize}
  \item Filesystems are everywhere.
  \item Yet they're poorly understood - especially by people who
    should.
  \item Modern filesystems have become increasingly complex, and so
    have the tools to analyse and recover data from them.
  \item It might be nice, it might be nice to verify that the
    filesystems and the tools actually provide the guarantees they
    claim to provide.
  \end{itemize}
\end{frame}

\begin{frame}{What we need}
  \begin{itemize}
    \item Our filesystem should offer a set of operations that are
      sufficient for running a workload.
    \item However, as theorem proving researchers, we are loath to
      construct more operations than necessary - so what's the minimal
      set?
    \item We could attempt to emulate the VFS and replicate the
      operations for inodes, dentries, and files.
    \item That would
      mean 19 inode operations, 6 dentry operations and 22 file operations.
  \end{itemize}
\end{frame}

%% \begin{frame}[fragile]
%% \begin{verbatim}
%% struct inode_operations {
%%         int (*create) (struct inode *, struct dentry *, int);
%%         struct dentry * (*lookup) (struct inode *, struct dentry *);
%%         int (*link) (struct dentry *, struct inode *, struct dentry *);
%%         int (*unlink) (struct inode *, struct dentry *);
%%         int (*symlink) (struct inode *, struct dentry *, const char *);
%%         int (*mkdir) (struct inode *, struct dentry *, int);
%%         int (*rmdir) (struct inode *, struct dentry *);
%%         int (*mknod) (struct inode *, struct dentry *, int, dev_t);
%%         int (*rename) (struct inode *, struct dentry *, struct inode *, struct dentry *);
%%         int (*readlink) (struct dentry *, char *,int);
%%         int (*follow_link) (struct dentry *, struct nameidata *);
%%         void (*truncate) (struct inode *);
%%         int (*permission) (struct inode *, int);
%%         int (*setattr) (struct dentry *, struct iattr *);
%%         int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
%%         int (*setxattr) (struct dentry *, const char *, const void *, size_t, int);
%%         ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
%%         ssize_t (*listxattr) (struct dentry *, char *, size_t);
%%         int (*removexattr) (struct dentry *, const char *);
%% };
%% \end{verbatim}
%% \end{frame}

\begin{frame}{Minimal set of operations?}
  \begin{itemize}
  \item There might be a better way, based on the Google file system.
  \item Here, we have a minimal set of operations:
    \begin{itemize}
    \item \texttt{create}
    \item \texttt{delete}
    \item \texttt{open}
    \item \texttt{close}
    \item \texttt{read}
    \item \texttt{write}
    \end{itemize}
  \item Further, we could leave \texttt{open} and \texttt{close} for
    the time when we want to deal with multiprogramming and
    concurrency.
  \item Thus, we have a minimal set of filesystem operations which we
    can model.
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item What should the filesystem look like?
  \item We're used to thinking of the filesystem as a tree... how
    about that?
  \item Thinking along the lines of recursive datatypes, an \texttt{alist}
    containing only strings or similar \texttt{alist}s in its
    \texttt{strip-cdrs} could do the job.
  \item The \texttt{strip-cars} would contain the file/directory
    names.
  \item Next, we'll look at a running example where we see what it
    looks like to add/delete files from such a model.
  \end{itemize}
\end{frame}

\begin{frame}{Our approach}
  \begin{itemize}
  \item Build a series of models, each providing a minimal set of
    operations and proofs of correctness of these operations.
  \item Per Ghemawat et al in SOSP 2003, a minimal set of operations
    can suffice - create, delete, open, close, read, and write files.
  \item Increasing the complexity of these operations with each model
    while proving equivalence with the previous model as we go would
    make the proofs tractable.
  \item There are many properties that could be considered for
    correctness, but the read-over-write theorems from the first-order
    theory of arrays seem like a good place to start.
    \begin {enumerate}
    \item Reading from a location after writing to the same location
      should yield the data that was written.
    \item Reading from a location after writing to a different
      location should yield the same result as reading before writing.
    \end {enumerate}
  \end{itemize}
\end{frame}

\begin{frame}{Progress so far}
  \begin{itemize}
    \item We've built three models, with the operations read, write,
      create, and delete.
      \begin{enumerate}
      \item In the first model, we represent the filesystem as a tree,
        allow for text files (stored as strings) and directories only,
        and store no metadata.
      \item In the second model, we add some metadata to our tree
        representation - namely, file length. We introduce a
        rudimentary fsck and prove that our operations of writing and
        deleting preserve correctness under fsck.
      \item In the third model, we retain the tree but also introduce
        an unlimited "disk" of fixed-length character blocks. We do
        away with the explicit strings holding the contents of text
        files and instead store lists of block indices in the tree.
      \end{enumerate}
    \item For each of these models, we have proofs of correctness of
      the two read-after-write properties, based on the proofs of
      equivalence between each model and its successor.
  \end{itemize}
\end{frame}

\begin{frame}{Proof approaches and techniques}
  \begin{itemize}
  \item In the fourth model, we implement garbage collection in the
    form of an allocation vector.
  \item What guarantees do we need to show that a filesystem of this
    kind is consistent?
  \end{itemize}
\end{frame}

\begin{frame}{Proof approaches and techniques}
  \begin{enumerate}
  \item The disk and the allocation vector must be in harmony
    initially and updated in lockstep.
  \item Every block referred to in the filesystem must be marked
    "used" in the allocation vector.\\
    \textit{What about the complementary problem - making sure unused
      blocks are unmarked?}
  \item If n blocks are available in the allocation vector, the
    allocation algorithm must provide n blocks when requested.
  \item No matter how many blocks are returned by the allocation
    algorithm, they must be unique and disjoint with the blocks
    allocated to other files.
  \end{enumerate}
\end{frame}

\begin{frame}{Future work}
  \begin{itemize}
  \item Finish finitising the length of the disk and garbage
    collecting disk blocks that are left unused after a write or a delete
    operation.
  \item Possibly, add the system call open and close with the
    introduction of file descriptors.\\
    \textit{This would be a step towards the study of concurrent FS operations.}
  \item Linearise the tree, leaving only the disk.
  \item Eventually emulate the CP/M filesystem as a convincing proof
    of concept, and move on to fsck and file recovery tools.
  \end{itemize}
\end{frame}

\end{document}
