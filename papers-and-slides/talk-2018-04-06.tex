% titlepage-demo.tex
\documentclass{beamer}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{matrix}
% items enclosed in square brackets are optional; explanation below
\title{Verifying the FAT32 filesystem in ACL2}
\author{Mihir Mehta}
\institute{
  Department of Computer Science\\
  University of Texas at Austin\\[1ex]
  \texttt{mihir@cs.utexas.edu}
}
\date{06 April, 2018}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}

\addtobeamertemplate{navigation symbols}{}{%
    \usebeamerfont{footline}%
    \usebeamercolor[fg]{footline}%
    \hspace{1em}%
    \large \insertframenumber/\inserttotalframenumber
}

\begin{document}

%--- the titlepage frame -------------------------%
\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}{Outline}
  \tableofcontents
\end{frame}

%--- the presentation begins here ----------------%

\section{Motivation and related work}

\begin{frame}{Why we need a verified filesystem}
  \begin{itemize}
  \item Filesystems are everywhere, even as operating systems move
    towards making them invisible.
  \item In the absence of a clear specification of filesystems, users
    (and sysadmins in particular) are underserved.
  \item Modern filesystems have become increasingly complex, and so
    have the tools to analyse and recover data from them.
  \item It would be worthwhile to specify and formally verify, in the
    ACL2 theorem prover, the guarantees claimed by filesystems and tools.
  \end{itemize}
\end{frame}

\begin{frame}{Related work}
  \begin{itemize}
  \item In Haogang Chen's 2016 dissertation, the author uses Coq to
    build a filesystem (named FSCQ) which is proven safe against
    crashes in a new logical framework named Crash Hoare Logic. His
    (exported) Haskell implementation performs comparably to ext4.
  \item Hyperkernel (Nelson et al., SOSP '17) is a "push-button"
    verification effort, but approximates by changing POSIX system
    calls for ease of verification.
  \item In our work, we instead aim to model an existing filesystem (FAT32)
    faithfully and match the resulting disk image byte-to-byte.
  \end{itemize}
\end{frame}

\section{Our approach}

\begin{frame}{Modelling a filesystem}
  \begin{itemize}
  \item We opt to iteratively model a filesystem, incrementally
    adding features of FAT32.
  \item This also allows us to prove correctness in an iterative
    fashion, by proving equivalences and thereby reusing correctness
    results from previous models.
  \item Apart from noting that some of these models were based on
    the previous technology target, the CP/M filesystem, we will not
    dwell on these.
  \end{itemize}
\end{frame}

\begin{frame}{Modelling a filesystem}
  \begin{itemize}
  \item In our most recent model, we separate our filesystem into:
    \begin{itemize}
    \item a tree, in which non-leaf nodes represent (sub)directories
      and leaf nodes represent regular files;
    \item a disk, containing the textual contents of regular files
      broken into fixed-size blocks;
    \item and a file allocation table, mapping each block in a regular
      file to the next, this allowing us to read the contents of the
      entire file.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Verifying the model}
  \begin{itemize}
  \item We've focussed so far on two filesystem properties, derived
    from the theory of arrays where they are known as the
    read-over-write properties.
    \begin{enumerate}
    \item After a write, a read of the same length at the same
      location should yield that which was written.
    \item After a write, a read at a different location should yield
      the same results as a read before the write.
    \end{enumerate}
  \item These properties have been proven for all models so far,
    including the present model which features a file allocation
    table.
  \end{itemize}
\end{frame}

\begin{frame}{Proof challenges}
  \begin{itemize}
  \item How do we define a "good state" of a filesystem, which shows
    that reading, writing and other operations can be safely carried
    out?
  \item Answering this question involves a trade-off between
    simplicity (to help with verification) and generality (to model as
    many real-world situations as possible.)
  \item We choose to require:
    \begin{itemize}
    \item that each block on the disk is attributed to at most one
      regular file;
    \item that the clusters attributed to each non-empty regular file
      end with a legal EOF value, as defined by the FAT specification.
    \item that each regular file is annotated with "length", a
      metadata field that corresponds to the actual length of the file
      as determined by traversing the file allocation table and
      reading the corresponding blocks.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Validating the model}
\end{frame}

\begin{frame}{Future work}
  \begin{enumerate}
  \item Complete the FAT32 model, by means of
    \begin{itemize}
    \item supporting variable cluster sizes,
    \item moving the file allocation table onto the disk, and
    \item moving all file and directory metadata from the tree to the
      disk.
    \end{itemize}
  \item Model a more complex filesystem, for instance NTFS, by
    re-using algorithms and proofs from the models built so far.
  \end{enumerate}
\end{frame}

\end{document}
