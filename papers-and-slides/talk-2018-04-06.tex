% titlepage-demo.tex
\documentclass{beamer}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{matrix}
% items enclosed in square brackets are optional; explanation below
\title{Verifying the FAT32 filesystem in ACL2}
\author{Mihir Mehta}
\institute{
  Department of Computer Science\\
  University of Texas at Austin\\[1ex]
  \texttt{mihir@cs.utexas.edu}
}
\date{06 April, 2018}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}

\addtobeamertemplate{navigation symbols}{}{%
    \usebeamerfont{footline}%
    \usebeamercolor[fg]{footline}%
    \hspace{1em}%
    \large \insertframenumber/\inserttotalframenumber
}

\begin{document}

%--- the titlepage frame -------------------------%
\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}{Outline}
  \tableofcontents
\end{frame}

%--- the presentation begins here ----------------%

\section{Introduction}

\begin{frame}{Why we need a verified filesystem}
  \begin{itemize}
  \item Filesystems are everywhere, even as operating systems move
    towards making them invisible.
  \item In the absence of a clear specification of filesystems, users
    (and sysadmins in particular) are underserved.
  \item Modern filesystems have become increasingly complex, and so
    have the tools to analyse and recover data from them.
  \item It would be worthwhile to specify and formally verify, in the
    ACL2 theorem prover, the guarantees claimed by filesystems and tools.
  \end{itemize}
\end{frame}

\begin{frame}{Why FAT32?}
  \begin{itemize}
  \item FAT32 was widely used in the days of Windows 2000; while the
    closely related FAT12 and FAT16 have mostly fallen into disuse,
    FAT32 continues to be used in removable media.
  \item It offers a simple design compared to other filesystems; while
    it lacks journalling, arguably an essential feature, it's a much
    easier target for verification.
  \item It's also not as unsophisticated as, say, the CP/M filesystem
    which doesn't support subdirectories. Thus, a verification effort
    for FAT32 can form a basis for verifying more complex filesystems.
  \end{itemize}
\end{frame}

\section{Our approach}

\begin{frame}{Refinement mappings (Abadi, 1991)}
  \begin{itemize}
  \item For a pair of transition systems $S_1$ and $S_2$, $S_1$ is said to
    \textit{implement} $S_2$ if every externally visible
    behaviour allowed by $S_1$ is also allowed by $S_2$.
  \item This implementation relation can be proved if (but not only
    if) a \textit{refinement mapping} can be discovered that maps
    each (state, transition) pair of $S_1$ to a legal (state,
    transition) pair of $S_2$.
  \item Proving an implementation relation of this kind, by starting
    with a simple system which can easily be reasoned about and
    refining one or more times to get to a system of sufficient
    complexity, is often a more tractable alternative to proving the
    correctness of the complex system from scratch.
  \end{itemize}
\end{frame}

\begin{frame}{Modelling a filesystem}
  \begin{itemize}
  \item We opt to iteratively model a filesystem, incrementally
    adding features of FAT32.
  \item This also allows us to prove correctness in an iterative
    fashion, by proving equivalences and thereby reusing correctness
    results from previous models.
  \item Apart from noting that some of these models were based on
    the previous technology target, the CP/M filesystem, we will not
    dwell on these.
  \end{itemize}
\end{frame}

\begin{frame}{Modelling a filesystem}
  \begin{itemize}
  \item In our most recent model, we separate our filesystem into:
    \begin{itemize}
    \item a tree, in which non-leaf nodes represent (sub)directories
      and leaf nodes represent regular files;
    \item a disk, containing the textual contents of regular files
      broken into fixed-size blocks;
    \item and a file allocation table, mapping each block in a regular
      file to the next, this allowing us to read the contents of the
      entire file.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Verifying the model}
  \begin{itemize}
  \item We've focussed so far on two filesystem properties, known in
    the literature as the \textit{read-over-write} properties.
    \begin{enumerate}
    \item After a write of some text at some location, a read of the
      same length at the same location should yield the text.
    \item After a write, a read at a different location should yield
      the same results as a read before the write.
    \end{enumerate}
  \item These properties have been proven for all models so far,
    including the present model which features a file allocation
    table.
  \end{itemize}
\end{frame}

\begin{frame}{Proof challenges}
  \begin{itemize}
  \item How do we define a "good state" of a filesystem, which shows
    that reading, writing and other operations can be safely carried
    out?
  \item Answering this question involves a trade-off between
    simplicity (to help with verification) and generality (to model as
    many real-world situations as possible.)
  \item We choose to require:
    \begin{itemize}
    \item that each block on the disk is attributed to at most one
      regular file;
    \item that the clusters attributed to each non-empty regular file
      end with a legal EOF value, as defined by the FAT specification.
    \item that each regular file is annotated with "length", a
      metadata field that corresponds to the actual length of the file
      as determined by traversing the file allocation table and
      reading the corresponding blocks.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Validating the model}
\end{frame}

\begin{frame}{Future work}
  \begin{enumerate}
  \item Complete the FAT32 model, by means of
    \begin{itemize}
    \item supporting variable cluster sizes,
    \item moving the file allocation table onto the disk, and
    \item moving all file and directory metadata from the tree to the
      disk.
    \end{itemize}
  \item Model a more complex filesystem, for instance NTFS, by
    re-using algorithms and proofs from the models built so far.
  \end{enumerate}
\end{frame}

\section{Related work and conclusion}

\begin{frame}{Related work}
  \begin{itemize}
  \item FSCQ (Chen, 2016) - Coq is used to build a filesystem , proven
    safe against crashes in a new logical framework named Crash Hoare
    Logic. Implementation (exported to Haskell) performs comparably to
    ext4.
  \item SibylFS (Ridge, 2015) - a "verifying compiler" of sorts is
    provided to translate specs in a DSL to C implementations.
  \item Hyperkernel (Nelson, 2017) - xv6 microkernel is implemented
    with system calls changed to make them constant-time, in return,
    verification burden becomes lightweight enough for Z3 SMT solver.
  \item In our work, we instead aim to model an existing filesystem (FAT32)
    faithfully and match the resulting disk image byte-to-byte.
  \end{itemize}
\end{frame}

\end{document}
