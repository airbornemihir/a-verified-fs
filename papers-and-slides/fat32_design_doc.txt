This is a design document for a proposed modelling and verification
effort for the FAT32 filesystem. We describe some essential features
of the filesystem, describe our iterative approach to modelling the
filesystem, and outline a strategy for proving properties about our
model as well as validating it through co-simulation with an
implementation.

--The FAT32 filesystem--
FAT32~\cite{microsoft_2000}~makes two fundamental design choices, which
are well-known in the filesystem literature. The first is the
treatment of directories like regular files, but with a special
attribute indicating they contain directory entries. (As a
consequence, we will use the term "file" in the rest of this document
to refer to both regular files and directories, using the more
specific terms where appropriate.) The second is the layout of file
data in units called clusters, fixed in size for a given FAT32 volume,
in order to facilitate longer sequential reads and writes and reduce
seek latency.

At a lower level, FAT32 chooses to record file ownership of clusters
in a data structure named a file allocation table, which contains, for
each file, a linked list of entries each pointing to the next. Further
it chooses to eschew the maintainance of a free list, which frees some
space, but at the cost of increasing the time taken to allocate free
clusters found by iterating through the file allocation table and
searching for free entries.

FAT32 limits filenames a maximum length of 12 characters, with up to 8
characters preceding a period and a 3 (or fewer) character extension
following the period. A variant, named VFAT, adds support for longer
filenames while maintaining compatibility with older FAT32 code which
cannot process these filenames.

--Linux implementation of FAT32--
FAT32 includes a notion of file permissions; permission errors (EPERM)
are returned in the following scenarios:
- during ioctl(2), when a file is marked as a system file (ATTR_SYS is
set) and the Linux capability for modifying immutable files is not
held.
- when setting file attributes, if file permissions (user/group/other)
are not in order.

Due to its use of caching, FAT32 is also suceptible to running out of
memory (ENOMEM) in the following scenarios:
- while zeroing out blocks, when a block is found which is already
zeroed.
- when allocating storage for a new directory, or when adding entries
to an existing directory, and no space is available in the buffer.
- when building a new inode, and no space is available.
- when the inode cache,FAT cache or superblock information data
structure cannot be created during initialisation.
- when allocating or freeing entries.

Finally, FAT32, like all filesystems, is susceptible to running out of
available space on the volume (ENOSPC). This leads to errors in the
following scenarios:
- when adding entries to a directory.
- more generally, when allocating clusters for a file operation.

--Modelling--
In order to manage the complexity inherent in modelling a filesystem,
we propose to model it in two stages, wherein we will name the models
M1 and M2.

An instance of M1 shall contain a tree representation of the directory
tree in a filesystem, and will thus lack the complexity of an actual
disk-based filesystem. Yet, a measure of "available space" shall be
maintained across file operations, so that file operations can be
rejected with appropriate error codes for lack of space, for
instance.

An instance of M2 will be a disk image, containing a
linearised representation of the directory tree along with all the
volume-level metadata that belongs in a real FAT32 volume. This is
intended to match FAT32's data layout at the byte level, implementing
the FAT32 file operations the same way as the Linux kernel
implementation does.

To model the Linux implementation of FAT32 with a reasonable level of
accuracy, we will need to include an in-memory "buffer" in our model,
which can hold some recently used file data and allow us to service
reads immediately which deferring writes for performance.
Initially, M1 and M2 are planned to only feature 4 regular file
operations - llseek (for moving to a specific location in a file),
read_iter (for buffered reading from a file), write_iter (for buffered
writing to a file) and fsync (for synchronising the buffer with the
disk.) For directory files, we plan to implement the
operations llseek, read, iterate_shared and fsync, which will allow us
to read and modify directories in the buffer, and synchronise the
buffer with the disk.

In tandem, we plan to co-simulate with the kernel
implementation, trying out a few common file and directory operations
and adding more file operations to this initial set as needed. This
co-simulation will be assisted by an existing filesystem utility
called bbfs, which provides a mountable filesystem serving only to log
the requested file operations and pass them on transparently to a
different underlying filesystem. Co-simulation of a sequence of
operations will then take the form of programmatically reading the log
produced by bbfs and re-playing the operations in our model.

--Proofs--
The central property we are trying to prove is the refinement relation
between L1 and L2; we can then prove properties of interest (such as
read-over-write properties) for L1 and derive them for L2 through
refinement. One way to prove refinement is by the construction of a
refinement mapping; this is our method of choice, made simpler by
keeping the set of file operations offered by M1 and M2 to be exactly
the same.

From past experience, it is expected that certain assumptions will
have to be made about the filesystem, which we will incorporate into
an invariant defining a "good filesystem". For instance, we will
assume that no cluster belongs to two different files at
once. Further, we will require that clusterchains (FAT32's term for
the linked lists showing the clusters held by individual files) end
with a legal EOF value, as stipulated by Microsoft's official FAT
specification. This will imply that all clusters marked with 0 are
free and available for use, which is also stipulated in Microsoft's
specification. This will simplify our reasoning about the number of
available clusters, and help us to show that file operations have
localised effects and do not affect other files.

--Goals and conclusion--
At the end of this exercise, we hope to have a pair of models, the
more complex of which models FAT32 up to co-simulation. We also hope to
show the correctness of the more complex model through refinement
proofs, which should help us show that the Linux FAT32 implementation
has these desirable read-over-write properties, or alternatively show
that bugs exist which can be fixed by bringing it into compliance with
our model.

For the moment, we exclude from our scope the verification of
filesystem generation utilities such as mkfs.fat(8) although we do
intend to validate the correctness of a generated filesystem with
respect to our "good filesystem" invariant. We also
exclude a detailed treatment of the effects of file operations on
memory, including sanitisation of user pointers and the like. We also
choose to model only short filenames (up to 12 characters long),
leaving VFAT for a later date.

We do not intend to conclude this verification effort with FAT32; we
plan to generate as many artefacts as possible during this
verification process as possible which will be of use in verification
efforts for more complex filesystems, such as ext4. Examples of these
/*BOZO: Cite Jonathan Corbet's LWN article about the asynchronous
read/write interface, and possibly talk more about the nature of this
asynchronous stuff. Also mention iterate_shared - I think this is how
things get added to directories... */
include our planned implementations of llseek, read_iter and
write_iter - FAT32 chooses to use Linux' generic implementations of
these file operations, and thus they are likely to be of use when
modelling a different filesystem that uses some or all of these
generic implementations.
